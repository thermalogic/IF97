
#![allow(warnings)]
use assert_approx_eq::assert_approx_eq;

use if97::pt;
use if97::common::*;


pub struct TestData {
    pub p: f64,
    pub T: f64,
    pub v: f64,
    pub h: f64,
    pub s: f64,
    pub u: f64,
    pub cp: f64,
    pub w: f64  
  }
#[test]
fn test_regino1_pt() {
    // Table 5，Page 9: p,T,v,h,u,s,cp,w
const p: [f64; 3] = [3.0, 80.0, 3.0];
const T: [f64; 3] = [300.0, 300.0, 500.0];

const v: [f64; 3] = [0.100215168e-2, 0.971180894e-3, 0.120241800e-2];
const h: [f64; 3] = [0.115331273e+3, 0.184142828e+3, 0.975542239e+3];
const s: [f64; 3] = [0.392294792, 0.368563852, 0.258041912e1];
const u: [f64; 3] = [0.112324818e3, 0.106448356e3, 0.971934985e3];
const cp: [f64; 3] = [0.417301218e1, 0.401008987e1, 0.465580682e1];
//const cv: [f64; 3] = [0.412120160e1, 0.391736606e1, 0.322139223e1];
const w: [f64; 3] = [0.150773921e4, 0.163469054e4, 0.124071337e4];

    for i in 0..3 {
        let t:f64 = T[i]- 273.15;
        assert_approx_eq!(v[i], pt(p[i],t, OV), 1.0e-9f64);
        assert_approx_eq!(h[i], pt(p[i],t, OH), 1.0e-6f64);
        assert_approx_eq!(s[i], pt(p[i],t, OS), 1.0e-9f64);
        assert_approx_eq!(u[i], pt(p[i],t, OU), 1.0e-6f64);
        assert_approx_eq!(cp[i],pt(p[i], t, OCP), 1.0e-8f64);
        //assert_approx_eq!(cv[i], if97::pt(p[i],t, OCV), 1.0e-8f64);
        assert_approx_eq!(w[i], pt(p[i], t, OW), 1.0e-5f64);
    }
}

 #[test]
 fn test_region2_pt()
 {
      //  Table15，Page17: p,T,v,h,u,s,cp,w
  const data:[TestData;3] = [
    TestData{p:0.0035,T:300.0, v:0.394913866E+02, h:0.254991145E+04, u:0.241169160E+04, s:0.852238967E+01, cp:0.191300162E+01, w:0.427920172E+03},
    TestData{p:0.0035, T:700.0, v:0.923015898E+02, h:0.333568375E+04, u:0.301262819E+04, s:0.101749996E+02, cp:0.208141274E+01,w:0.644289068E+03},
    TestData{p:30.0, T:700.0, v:0.542946619E-02, h:0.263149474E+04, u:0.246861076E+04, s:0.517540298E+01, cp:0.103505092E+02,w:0.480386523E+03}];
  
    for i in 0..2
    {
      let p:f64 = data[i].p;
      let t:f64 = data[i].T- 273.15;
      assert_approx_eq!(data[i].v, pt(p, t, OV), 1.0e-6f64); 
      assert_approx_eq!(data[i].h, pt(p, t, OH), 1.0e-5f64); 
      assert_approx_eq!(data[i].s, pt(p, t, OS), 1.0e-6f64);
      assert_approx_eq!(data[i].u, pt(p, t, OU), 1.0e-5f64);
      assert_approx_eq!(data[i].cp,pt(p,t, OCP), 1.0e-6f64);
      assert_approx_eq!(data[i].w, pt(p,t, OW), 1.0e-6f64);
     
    }
  }

#[test] 
fn test_region3_pt()
{
  //_Backward3_PT v， p,T
  const tab:[[f64;3];52] = [
      [1.470853100e-3, 50.0, 630.0], // a
      [1.503831359e-3, 80.0, 670.0],
      [2.204728587e-3, 50.0, 710.0], // b
      [1.973692940e-3, 80.0, 750.0],
      [1.761696406e-3, 20.0, 630.0], // c
      [1.819560617e-3, 30.0, 650.0],
      [2.245587720e-3, 26.0, 656.0], // d
      [2.506897702e-3, 30.0, 670.0],
      [2.970225962e-3, 26.0, 661.0], // e
      [3.004627086e-3, 30.0, 675.0],
      [5.019029401e-3, 26.0, 671.0], // f
      [4.656470142e-3, 30.0, 690.0],
      [2.163198378e-3, 23.6, 649.0], // g
      [2.166044161e-3, 24.0, 650.0],
      [2.651081407e-3, 23.6, 652.0], // h
      [2.967802335e-3, 24.0, 654.0],
      [3.273916816e-3, 23.6, 653.0], // i
      [3.550329864e-3, 24.0, 655.0],
      [4.545001142e-3, 23.5, 655.0], // j
      [5.100267704e-3, 24.0, 660.0],
      [6.109525997e-3, 23.0, 660.0], // k
      [6.427325645e-3, 24.0, 670.0],
      [2.117860851e-3, 22.6, 646.0], // l
      [2.062374674e-3, 23.0, 646.0],
      [2.533063780e-3, 22.6, 648.6], // m
      [2.572971781e-3, 22.8, 649.3],
      [2.923432711e-3, 22.6, 649.0], // n
      [2.913311494e-3, 22.8, 649.7],
      [3.131208996e-3, 22.6, 649.1], // o
      [3.221160278e-3, 22.8, 649.9],
      [3.715596186e-3, 22.6, 649.4], // p
      [3.664754790e-3, 22.8, 650.2],
      [1.970999272e-3, 21.1, 640.0], // q
      [2.043919161e-3, 21.8, 643.0],
      [5.251009921e-3, 21.1, 644.0], // r
      [5.256844741e-3, 21.8, 648.0],
      [1.932829079e-3, 19.1, 635.0], // s
      [1.985387227e-3, 20.0, 638.0],
      [8.483262001e-3, 17.0, 626.0], // t
      [6.227528101e-3, 20.0, 640.0],
      [2.268366647e-3, 21.5, 644.6], // u
      [2.296350553e-3, 22.0, 646.1],
      [2.832373260e-3, 22.5, 648.6], // v
      [2.811424405e-3, 22.3, 647.9],
      [3.694032281e-3, 22.15, 647.5], // w
      [3.622226305e-3, 22.3, 648.1],
      [4.528072649e-3, 22.11, 648.0], // x
      [4.556905799e-3, 22.3, 649.0],
      [2.698354719e-3, 22.0, 646.84], // y
      [2.717655648e-3, 22.064, 647.05],
      [3.798732962e-3, 22.0, 646.89], // z
      [3.701940010e-3, 22.064, 647.15]];

  for i in 0..52
  {
    let p:f64 = tab[i][1];
    let t:f64 = tab[i][2]-273.15;
    assert_approx_eq!(tab[i][0], pt(p, t,OV));
  }
}

#[test]
fn test_region5_pt()
{
 // Table 42, page 40 T,p  v,h,u,s,cp,w
 const data:[[f64;8];3] = [
          [1500.0, 0.5, 1.38455090, 0.521976855e+4, 4527.49310, 9.65408875, 2.61609445, 917.068690],
          [1500.0, 30.0, 0.0230761299, 5167.23514, 4474.95124, 7.72970133, 2.72724317, 928.548002],
          [2000.0, 30.0, 0.0311385219, 6571.22604, 5637.07038, 8.53640523, 2.88569882, 1067.36948]];
  for i in 0..2
  {
    let t:f64 = data[i][0]-273.15;
    let p:f64 = data[i][1];
    assert_approx_eq!(data[i][2], pt(p, t, OV), 1.0e-6f64); 
    assert_approx_eq!(data[i][3], pt(p, t, OH), 1.0e-4f64); 
    assert_approx_eq!(data[i][4], pt(p, t, OU), 1.0e-4f64);
    assert_approx_eq!(data[i][5], pt(p, t, OS), 1.0e-5f64);
    assert_approx_eq!(data[i][6], pt(p,t, OCP), 1.0e-6f64);
    assert_approx_eq!(data[i][7], pt(p,t, OW), 1.0e-6f64);
   
  }
}